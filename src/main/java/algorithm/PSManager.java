package algorithm;

import graph.Edge;
import graph.Graph;
import graph.Node;

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.TreeSet;

/**
 * This static class utilises the Partial solutions to generate children partial solutions.
 * author: Sam Li, Edison Rho, Nathan Hur
 */

public class PSManager {

    private Graph _graph;
    private int _numberOfProcessors;

    public PSManager(int processors){
        _numberOfProcessors = processors;
    }

    public PriorityQueue<PartialSolution> initialise() {

        return null;
    }

    //BFS of  children of partial solution
    //for ever node, addNode to add to partial solution then return that
    //calculate functional cost i.e. the max formula

    /**
     * Returns a list of lower level partial solutions from a given partial solution.
     * It uses all the free variables that are available from the input partial solution
     * and generates partial solutions from those free variables.
     * @param partialSolution
     * @return
     */
    public List<PartialSolution> generateChildren(PartialSolution prevPartialSolution){
        List<Node> freeNodes = getFreeNodes(prevPartialSolution);
        //for every free node, create the partial solutions that can be generated
        for (Node freeNode: freeNodes) {

            //for every processor, create partial solution that can be generated by scheduling the
            //free variable to that processor.
            for (int i = 0; i < _numberOfProcessors; i++){
                PartialSolution partialSolution = new PartialSolution(_numberOfProcessors);
            }
        }

    }

    private List<Node> getFreeNodes(PartialSolution prevPartial){
        List<Node> freeNodes = new ArrayList<Node>();
        List<Node> nodes = _graph.getNodes();

        //get all the free variables from list of all nodes in graph
        List<Edge> predecessorEdges;
        allNodes: for (Node node : nodes){
            predecessorEdges = node.getIngoing().;
            //check each predecessor of the node to see if it's in schedule already
            predecessors: for (Edge trialEdge : predecessorEdges) {
                if (!prevPartial.contains(trialEdge.getFrom())){
                    continue allNodes;
                }
            }
            //add to list of free nodes if all predecessors in schedule
            freeNodes.add(node);
        }

        return freeNodes;
    }
}
