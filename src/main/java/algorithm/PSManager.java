package algorithm;

import graph.Edge;
import graph.Graph;
import graph.Node;
import logger.Logger;

import java.util.*;

/**
 * This static class utilises the Partial solutions to generate children partial solutions.
 * author: Sam Li, Edison Rho, Nathan Hur
 */

public class PSManager {

    private Graph _graph;
    private int _numberOfProcessors;

    //calculate all bottom level work values and cache them for the cost function
    private HashMap<String, Integer> _bottomLevelWork;

    //cache the constant portion of the idle time heuristic (total work / processors)
    private int _idleConstantHeuristic;

    public PSManager(int processors, Graph graph){
        _numberOfProcessors = processors;
        _graph = graph;
        _idleConstantHeuristic = graph.totalMinimumWork() / processors;
        _bottomLevelWork = bottomLevelCalculator(graph);
    }

    //BFS of  children of partial solution
    //for ever node, addNode to add to partial solution then return that
    //calculate functional cost i.e. the max formula

    /**
     * Add the children of a partial solution to a given PSPriorityQueue
     * It uses all the free variables that are available from the input partial solution
     * and generates partial solutions from those free variables.
     * @param parentPS the parent partial solution to generate children from
     * @param queue the queue to add the children to
     * @return
     */
    public void generateChildren(PartialSolution parentPS, PSPriorityQueue queue) {

        List<Node> freeNodes = getFreeNodes(parentPS);
        //for every free node, create the partial solutions that can be generated
        for (Node freeNode: freeNodes) {
            //calculate latest time to put on (dependency)
            int[] earliestTimeOnProcessor = earliestTimeOnProcessors(parentPS, freeNode);
            //for every processor, create partial solution that can be generated by scheduling the
            //free variable to that processor. Calculate the new cost and add it to the priority queue.
            for (int i = 0; i < _numberOfProcessors; i++){
                ProcessorSlot slot = new ProcessorSlot(freeNode, earliestTimeOnProcessor[i], i);
                PartialSolution partialSolution = new PartialSolution(parentPS);
                addSlot(partialSolution, slot);
                calculateUnderestimate(partialSolution);
                queue.add(partialSolution);
            }
        }
    }

    /**
     * Calculates the bottomLevel value for all nodes in the graph, this only has to be run once in the initialization
     * of the PSManager
     * @param graph
     * @return
     */
    private static HashMap<String,Integer> bottomLevelCalculator(Graph graph) {
        List<Node> allNodes = graph.getNodes();
        HashMap<String, Integer> bottomLevels = new HashMap<String, Integer>(allNodes.size());
        Queue<Node> queuedNodes = new LinkedList<Node>();
        Node predecessorNode;
        Node currentNode;
        int maxBottomLevel;
        int currentNodeBL;
        boolean allSuccessorsCalculated;

        for(Node node: allNodes) {
            if(node.getOutgoing().isEmpty()) {
                queuedNodes.add(node);
            }
        }

        while(!queuedNodes.isEmpty()) {
            maxBottomLevel = 0;
            currentNode = queuedNodes.remove();
            if (!currentNode.getOutgoing().isEmpty()) {
                for (Edge successors : currentNode.getOutgoing()) {
                    currentNodeBL = bottomLevels.get(successors.getTo().getName());
                    if (currentNodeBL > maxBottomLevel) {
                        maxBottomLevel = currentNodeBL;
                    }
                }
            }
            bottomLevels.put(currentNode.getName(),maxBottomLevel + currentNode.getWeight());
            if (!currentNode.getIncoming().isEmpty()) {
                for (Edge predecessors : currentNode.getIncoming()) {
                    predecessorNode = predecessors.getFrom();
                    allSuccessorsCalculated = true;
                    for (Edge pSuccessors : predecessorNode.getOutgoing()) {
                        if (!bottomLevels.containsKey(pSuccessors.getTo().getName())) {
                            allSuccessorsCalculated = false;
                        }
                    }
                    if (allSuccessorsCalculated) {
                        queuedNodes.add(predecessorNode);
                    }
                }
            }
        }
        return bottomLevels;
    }

    /**
     * Function to calculate and update the work for a partialSolution
     * @param ps a partial solution
     */
    private void calculateUnderestimate(PartialSolution ps) {

        // get bottom level work
        int bottomLevelWork = _bottomLevelWork.get(ps._latestSlot._node.getName());

        // update idle time heuristic TODO: optimise
        int idleTimeHeuristic = _idleConstantHeuristic + ps._idleTime / _numberOfProcessors;


        // update estimate
        ps._cost = Math.max(ps._cost, Math.max(idleTimeHeuristic, bottomLevelWork));
    }

    private List<Node> getFreeNodes(PartialSolution parentPS){
        List<Node> freeNodes = new ArrayList<Node>();
        List<Node> nodes = _graph.getNodes();

        //get all the free variables from list of all nodes in graph
        List<Edge> predecessorEdges;
        allNodes: for (Node node : nodes){
            predecessorEdges = node.getIncoming();
            //check each predecessor of the node to see if it's in schedule already
            predecessors: for (Edge trialEdge : predecessorEdges) {
                if (!contains(parentPS, trialEdge.getFrom())){
                    continue allNodes;
                }
            }
            //add to list of free nodes if all predecessors in schedule
            freeNodes.add(node);
        }

        return freeNodes;
    }

    /**
     * This finds the earliest time on each processor that a node can be scheduled to
     * based on successor nodes and the latest slot finishing time on each processor.
     * @param parentPS
     * @param freeNode
     * @return int[] index is the processor, value is the time
     */
    private int[] earliestTimeOnProcessors(PartialSolution parentPS, Node freeNode) {
        int[] earliestTimes = new int[_numberOfProcessors];
        ArrayList<Node> parents = freeNode.getParentNodes();
        int maxTime = 0;
        ProcessorSlot maxSlot = null;
        for (int i = 0; i < _numberOfProcessors; i++) {
            ArrayList<ProcessorSlot> processor = parentPS._processors[i];
            for (int j = processor.size() - 1; j >= 0; j--) {
                ProcessorSlot slot = processor.get(j);
                if (slot._finish >= maxTime) {
                    if (parents.contains(slot._node)) {
                        maxTime = slot._finish;
                        maxSlot = slot;
                    }
                } else {
                    break;
                }
            }
        }

        //DEBUG
        if (maxSlot == null) Logger.error("maxSlot not found (earliestTimeOnProcessors)");

        int maxTimeWithProcessorTransfer = maxSlot._finish + _graph.getEdge(new Edge(maxSlot._node, freeNode, 0)).getWeight();
        for (int k = 0; k < _numberOfProcessors; k++) {
            earliestTimes[k] = Math.max(maxTimeWithProcessorTransfer, parentPS._latestSlots[k]._finish);
        }
        // earliest time on the processor with the latest successor has no processor transfer time
        earliestTimes[maxSlot._processor] = Math.max(maxTime, parentPS._latestSlots[maxSlot._processor]._finish);
        return earliestTimes;
    }

    /**
     * check if a node is present within the schedule of the partial schedule.
     * @param node
     * @return
     */
    protected boolean contains(PartialSolution ps, Node node){
        for (ArrayList<ProcessorSlot> processor : ps._processors){
            if (processor.contains(node)){
                return true;
            }
        }
        return false;
    }

    /**
     * Add a slot to a processor, updating latestSlots, latestSlot and idleTime as necessary
     * @param slot
     */
    public void addSlot(PartialSolution ps, ProcessorSlot slot) {
        int prevSlotFinishTime = ps._latestSlots[slot._processor]._finish;
        int processor = slot._processor;
        ps._processors[processor].add(slot);
        ps._idleTime += slot._start - prevSlotFinishTime;
        ps._latestSlots[processor] = slot;
        if (ps._latestSlot == null || ps._latestSlot._finish < slot._finish) {
            ps._latestSlot = slot;
        }
    }
}
