package algorithm;

import graph.Edge;
import graph.Graph;
import graph.Node;

import java.util.*;

/**
 * This static class utilises the Partial solutions to generate children partial solutions.
 * author: Sam Li, Edison Rho, Nathan Hur
 */

public class PSManager {

    //Hashset in PSManager, if you've calculated it before, Memoization.
    private HashSet<Integer> _bottomLevels;
    private Graph _graph;
    private int _numberOfProcessors;

    public PSManager(int processors){
        _numberOfProcessors = processors;
    }

    public PriorityQueue<PartialSolution> initialise() {

        return null;
    }

    //BFS of  children of partial solution
    //for ever node, addNode to add to partial solution then return that
    //calculate functional cost i.e. the max formula

    /**
     * Returns a list of lower level partial solutions from a given partial solution.
     * It uses all the free variables that are available from the input partial solution
     * and generates partial solutions from those free variables.
     * @return
     */
    public List<PartialSolution> generateChildren(PartialSolution prevPartialSolution){
        List<Node> freeNodes = getFreeNodes(prevPartialSolution);
        //for every free node, create the partial solutions that can be generated
        for (Node freeNode: freeNodes) {

            //for every processor, create partial solution that can be generated by scheduling the
            //free variable to that processor.
            for (int i = 0; i < _numberOfProcessors; i++){
                PartialSolution partialSolution = new PartialSolution(_numberOfProcessors);
            }
        }
    return null;
    }

    /**
     * Calculates the bottomLevel value for all nodes in the graph, this only has to be run once in the initialization
     * of the PSManager
     * @param graph
     * @return
     */
    public static HashMap<String,Integer> bottomLevelCalculator(Graph graph) {
        List<Node> allNodes = graph.getNodes();
        HashMap<String, Integer> bottomLevels = new HashMap<String, Integer>(allNodes.size());
        Queue<Node> queuedNodes = new LinkedList<Node>();
        Node predecessorNode;
        Node currentNode;
        int maxBottomLevel;
        int currentNodeBL;
        boolean allSuccessorsCalculated;

        for(Node node: allNodes) {
            if(node.getOutgoing().isEmpty()) {
                queuedNodes.add(node);
            }
        }

        while(!queuedNodes.isEmpty()) {
            maxBottomLevel = 0;
            currentNode = queuedNodes.remove();
            if (!currentNode.getOutgoing().isEmpty()) {
                for (Edge successors : currentNode.getOutgoing()) {
                    currentNodeBL = bottomLevels.get(successors.getTo().getName());
                    if (currentNodeBL > maxBottomLevel) {
                        maxBottomLevel = currentNodeBL;
                    }
                }
            }
            System.out.println("node: "+currentNode.getName());
            System.out.println("ingoing nodes: "+currentNode.getIngoing().size());
            bottomLevels.put(currentNode.getName(),maxBottomLevel + currentNode.getWeight());
            if (!currentNode.getIngoing().isEmpty()) {
                for (Edge predecessors : currentNode.getIngoing()) {
                    predecessorNode = predecessors.getFrom();
                    allSuccessorsCalculated = true;
                    for (Edge pSuccessors : predecessorNode.getOutgoing()) {
                        if (!bottomLevels.containsKey(pSuccessors.getTo().getName())) {
                            allSuccessorsCalculated = false;
                        }
                    }
                    if (allSuccessorsCalculated) {
                        queuedNodes.add(predecessorNode);
                    }
                }
            }
        }
        return bottomLevels;
    }

    private List<Node> getFreeNodes(PartialSolution prevPartial){
        List<Node> freeNodes = new ArrayList<Node>();
        List<Node> nodes = _graph.getNodes();

        //get all the free variables from list of all nodes in graph
        List<Edge> predecessorEdges;
        allNodes: for (Node node : nodes){
            predecessorEdges = node.getIngoing();
            //check each predecessor of the node to see if it's in schedule already
            predecessors: for (Edge trialEdge : predecessorEdges) {
                if (!prevPartial.contains(trialEdge.getFrom())){
                    continue allNodes;
                }
            }
            //add to list of free nodes if all predecessors in schedule
            freeNodes.add(node);
        }

        return freeNodes;
    }
}
